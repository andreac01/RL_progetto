\documentclass[12 pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[italian]{babel}
\usepackage{graphicx} % Required for inserting images
\usepackage{hyperref}
\usepackage{svg}
\usepackage[export]{adjustbox}


\title{\textbf{Prova Finale: Progetto di Reti logice}}
\author{Andrea Cerutti, Marco Alfano}
\date{a.a. 2022-2023}

\begin{document}

\maketitle
\hspace{60 pt}
\begin{center}
    \includegraphics[scale = 0.5]{images/politecnico_logo.png}
\end{center}

\begin{theindex}
    \item \hyperref[intro]{1 Introduzione}
        \subitem \hyperref[intro]{ 1.1 Obiettivi}
        \subitem \hyperref[spec]{ 1.2 Specifiche generali}
        \subitem \hyperref[comp]{ 1.3 Descrizione Componente}
        \subitem \hyperref[mem]{ 1.4 Descrizione Memoria}

\indexspace
    \item \hyperref[intro]{2 Architettura}
        \subitem \hyperref[deserializzatore]{ 2.1 Deserializzatore}
        \subitem \hyperref[demux]{ 2.2 De-multiplexer}
        \subitem \hyperref[registri]{ 2.3 Registri in uscita}
        \subitem \hyperref[fsm]{ 2.4 FSM}
        \subitem \hyperref[supporto]{ 2.5 Moduli di supporto}
\indexspace
    \item \hyperref[]{ 3 Sintesi}
        \subitem \hyperref[]{ 3.1 Utilization}
        \subitem \hyperref[]{ 3.1 Timing}
        \subitem \hyperref[]{ 3.2 Schematica}
\indexspace
    \item \hyperref[]{ 4 Simulazione}
        \subitem \hyperref[]{ 4.1 Funzionamento generale e casi base}
        \subitem \hyperref[]{ 4.2 Reset}
\indexspace
    \item \hyperref[conclusioni]{ 5 Conclusioni }
\end{theindex}

\section{Introduzione}
\label{intro}
    \subsection{ Obiettivi}
    Lo scopo del progetto è quello di sintetizzare un componente hardware avente le caratteristiche descritte nelle sezioni \hyperref[spec]{1.2}, \hyperref[comp]{1.3} e \hyperref[mem]{1.4}. Il linguaggio di descrizione hardware richiesto è VHDL da utilizzare insieme al software Vivado usato per sintesi e simulazioni.
    
\subsection{Specifiche generali}
    \label{spec}
    Il componente hardware da sintetizzare deve essere in grado di eseguire correttamente le seguenti operazioni:
    \begin{enumerate}
        \item Deserializzare una sequenza di dati in input composta da:
        \begin{itemize}
            \item Esattamente 2 bit rappresentanti il codice identificativo del canale di uscita da utilizzare.
            \item Una serie di bit avente lunghezza compresa tra 0 e 16. Questa sequenza rappresenta la componente meno significativa di un indirizzo di memoria a 16 bit (ogni eventuale bit mancante è da considerare uguale a '0').
        \end{itemize}
        \item Richiedere ad una memoria, da intendersi come componente esterno, la parola contenuta all'indirizzo di 16 bit precedentemente calcolato.
        \item Salvare la parola di 8 bit ottenuta dalla memoria e condividerla per un ciclo di clock sul canale di uscita precedentemente calcolato. Durante questo ciclo di clock sugli altri 3 canali di uscita verranno condivisi i valori che avevano assunto durante l'iterazione precedente.
    Sono inoltre presenti alcune restrizioni:
    \begin{itemize}
        \item Il componente deve essere funzionante quando il periodo di clock è almeno 100 ns.
        \item Il numero di cicli di clock che intercorrono tra  fine della lettura dell'input serializzato alla pubblicazione sui canali di uscita deve essere minore di 20.
    \end{itemize}
    \end{enumerate}
\subsection{Descrizione componente}
\label{comp}
    Il modulo richiesto presenta due ingressi primari da 1 bit che rappresentano il segnale di inizio (i\_start) e l'ingresso dell'input serializzato (i\_w). Sono inoltre presenti in ingresso il segnale di clock (i\_clk) e un segnale di reset (i\_reset) che permette di reinizializzare il modulo ponendo i contenuti salvati sui canali di uscita al valore '00000000' e portando lo stato della FSM corrispondente al valore iniziale.
    Di seguito riportiamo uno schema basilare del componente. Da notare che l'interfaccia con la memoria è solamente abbozzata in quanto verrà specificata nella prossima sezione.
    \newline
    \begin{center}
        \includegraphics[scale=0.65]{images/modulo.png}
    \end{center}

\pagebreak

\subsection{Descrizione memoria}
\label{mem}
    La memoria con cui il componente deve interfacciarsi è da considerarsi come un modulo separato il cui comportamento rispetta le specifiche di seguito descritte.
    La memoria riceve in ingresso i seguenti segnali:
    \begin{itemize}
        \item clk:  corrispettivo del segnale di clock (i\_clk)
        \item we:   segnale composto che se posto a '1' permette l'accesso alla memoria in scrittura, se posto a '0' permette l'accesso in lettura. Nel progetto corrisponde al segnale o\_mem\_we.
        \item en:   segnale che attiva l'interfaccia della memoria. Quando posto a '1' è possibile accedervi in lettura o scrittura. Quando posto a '0' non è possibile eseguire operazioni su di essa. Nel progetto corrisponde al segnale o\_mem\_en.
        \item addr: segnale di 16 bit in parallelo che rappresentano l'indirizzo di memoria cui accedere. Nel progetto corrisponde al segnale o\_mem\_addr.
        \item di:   segnale di 8 bit in parallelo che rappresenta la parola da scrivere in memoria. Nel casi in cui en='0' e/o we='0' questo segnale non viene utilizzato. Nel progetto corrisponde al segnale o\_mem\_di.
    \end{itemize}
    In uscita invece troviamo un unico segnale:
    \begin{itemize}
        \item do:   segnale di 8 bit in parallelo che rappresentano la parola di memoria letta o scritta a seconda del valore di we. Nel progetto corrisponde al segnale o\_mem\_do.
    \end{itemize}
    Di seguito quindi riportiamo una schematica della memoria:
    \begin{center}
        \includegraphics[scale=0.32]{images/memoria.png}
    \end{center}
    Un'ulteriore informazione particolarmente significativa per la modellizzazione del nostro componente è il tempo di risposta della memoria. Essa infatti presenta un ritardo pari a 2ns tra l'istante in cui viene richiesta e/o effettuata un'operazione sulla memoria e la propagazione dell'output corrispondente sul segnale do.
    Risulta importante notare che per i nostri scopi la scrittura in memoria risulta superflua.









\label{architettura}
\section{Architettura}
    Prima di entrare nei dettagli di ogni modulo presente nel componente diamo una visione d'insime della sua struttura. I moduli principali sono un deserializzatore per leggere e salvare il segnale in inpunt, un blocco di 4 registri in uscita per salvare gli output precedenti, una macchina a stati finiti per pilotare correttamente questi componenti e gestire l'interfaccia con la memoria. A questi componenti si aggiungono altri moduli secondari e di supporto.
    \label{deserializzatore}
    \subsection{Deserializzatore}
        Il primo modulo del progetto è un deserializzatore ovvero un componente in grado di trasformare una sequenza seriale di bit in ingresso in un segnale parallelo equivalente. Per gli scopi del progetto il componente deve essere pilotabile in modo da deserializzare scrivendo, a scelta, su due registri differenti:
        \begin{itemize}
            \item reg\_ch: registro di 2 bit utilizzato per comunicare il canale di uscita correntemente selezionato.
            \item reg\_addr: registro di 16 bit utilizzato per comunicare l'indirizzo di memoria da cui leggere.
        \end{itemize}
        Per quanto riguarda gli ingressi del componente troviamo:
        \begin{itemize}
            \item i\_clk: è il segnale di clock comune a tutti i processi sequenziali del progetto
            \item i\_w: è l'ingresso seriale a singolo bit da cui vengono letti il codice del canale di uscita e l'indirizzo di memoria.
            \item i\_start: è il segnale che determina il periodo di attività del modulo: qunado posto a '1' il deserializzatore viene abilitato.
            \item we\_ch: è il segnale che determina l'inizio della conversione del segnale seriale in ingresso che trasporta l'informazione relativa al canale di uscita.
            \item we\_addr: è il segnale che determina la conversione del segnale seriale in ingresso che trasporta l'informazione relativa all'indirizzo di memoria.
            \item clr\_addr: è un segnale utilizzato per svuotare il registro relativo all'indirizzo di memoria. Tale operazione è resa necessaria dalla possibilità di ricevere tale indirizzo come una sequenza di bit di lunghezza variabile (tra 0 e 16 bit).
        \end{itemize}
        Da notare che gli ultimi 3 segnali non fanno parte degli input definiti dalle specifiche bensì sono segnali pilotati da una macchina a stati finiti.
        Inoltre data la sua struttura questo modulo è stato descritto in VHDL attraverso due processi distinti.
        Per descrivere questo componente abbiamo sfruttato dei segnali del tipo 'unsigned' fornito dalla libreria IEEE.numeric\_std. Questo tipo infatti fornisce l'operazione di shift che risulta particolarmente utile per deserializzare segnali.
    \label{demux}
    \subsection{De-multiplexer}
        Il secondo modulo è un componente ben noto dal corso di reti logiche. Si tratta infatti di un semplice DMUX che permette di selezionare il registro di uscita, tra i quattro possibili, su cui scrivere. In particolare i segnali relativi a questo componente sono:
        \begin{itemize}
            \item reg\_ch: segnale di due bit proveniente dal deserializzatore che rappresenta la codifica binaria del canale di uscita da abilitare.
            \item write: rappresenza il segnale da propagare verso l'uscita del DMUX selezionata.
            \item we\_z0, we\_z1, we\_z2, we\_z3: rappresentano le uscite del DMUX. Ogni uscita, se posta ad '1', abilita la scrittura sul registro di uscita corrispondente. Questi segnali sono tutti posti di default a '0' e quando selezionati assumono il valore del segnale 'write'.
        \end{itemize}

\pagebreak
        
    \label{registri}
    \subsection{Registri in uscita}
        Il terzo componente è composto dall'insieme di 4 identici moduli con lo scopo di mantenere memoria dell'ultima parola trasmessa su ogni canale di uscita. I segnali coinvolti nella gestione di ciascun registro sono:
        \begin{itemize}
            \item i\_clk: come tutti i componenti sequenziali nel progetto anche questi registri richiedo il segnale di clock in ingresso.
            \item i\_rst: se posto a '1' porta a svuotare tutti i registri.
            \item we\_zi: è il segnale in ingresso all'i-esimo registro che abilita la scrittura su di esso (i=0..3).
            \item i\_mem\_data: è la parola di memoria in ingresso al componente. Se la scrittura è abilitata questo segnale di 8 bit viene salvato nel registro.
        \end{itemize}
        Quando richiesto, il contenuto di questi registri viene trasmesso sui canali di uscita corrspondenti.
    \label{fsm}
    \subsection{FSM}
        Altro componente fondamentale è una macchina a stati adibita alla gestione e integrazione dei differenti moduli.
        In particolare si tratta di una macchina di Moore che lavora sul fronte di salita del clock e che può essere riportata asincronamente allo stato iniziale ponendo i\_rst al valore '1'.
        I segnali pilotati dalla FSM sono:
        \begin{itemize}
            \item we\_ch: Comunica al deserializzatore che deve scrivere sul registro relativo alla scelta del canale in uscita. Il valore di default è '0'.
            \item we\_addr: Comunica al deserializzatore che deve scrivere sul registro relativo alla selezione dell'indirizzo di memoria. Il valore di default è '0'.
            \item clr\_addr: Comunica al deserializzatore la necessità di svuotare il registro relativo all'indirizzo di memoria. Il valore di default è '1'.
            \item write: Abilita la scrittura sul registro di uscita selezionato dal DMUX. Il valore di default è '0'.
            \item o\_mem\_we: è il segnale che abilita la scrittura sulla memoria. Il valore di default è '0' e non viene mai modificato.
            \item contested\_mem\_en: Segnale utilizzato come lock 
            per abilitare o disabilitare la possibilità di accesso alla memoria ovvero di porre o\_mem\_en a '1'. Il valore di default è '0'.
            \item out\_en: corrisponde al segnale o\_done. I due segnali vengono sincronizzati da un processo esterno sul fronte di salita del clock. Il valore di default è '0'.
        \end{itemize}
        Gli stati della FSM sono 5. Di seguito spieghiamo brevemente il loro funzionamento.
        \begin{itemize}
            \item WAIT\_START: In questo stato il componente si trova in attesa che il segnale di start assuma il valore '1'. Per ottenere correttamente il primo bit relativo al canale di uscita il deserializzatore continua a scrivere sul registro corrispondente. Questa ottimizzazione è resa possibile dal fatto che il canale di uscita è sempre identificato tramite una sequenza di 2 bit. Per questo motivo in questo stato we\_ch ha valore '1'. Quando start assume valore '1' la macchina passa allo stato GET\_CHANNEL.
            \item GET\_CHANNEL: In questo stato il deserializzatore ascolta il secondo bit relativo al canale di uscita. Pertanto anche in questo stato we\_ch assume il valore '1'. Il componente rimane in questo stato solamente per un ciclo di clock prima di passare a GET\_ADDR.
            \item GET\_ADDR: Dopo aver terminato di deserializzare l'indirizzo del canale di uscita la FSM imposta we\_addr al valore '1' e clr\_addr a '0'. Ciò porta il deserializzatore ad elaborare l'indirizzo di memoria leggendo da i\_w. Inoltre viene posto contested\_mem\_en a '1' cosa che permette attraverso un ulteriore processo di supporto di richiedere la parola di memoria nella posizione correntemente calcolata non appena i\_start assume il valore '0'. Sul fronte di salita successivo a i\_start = '0' lo stato della macchina passa a WRITE\_IN.
            \item WRITE\_IN: In questo stato la macchina riceve la risposta da parte della memoria nella prima metà del clock. Sul fronte di discesa, ovvero a metà del clock corrispondente a questo stato, viene effettuata la scrittura dei valori letti dalla memoria sul registro corrispondente al canale selezionato. Per compiere le operazioni di  lettura clr\_addr viene posto a '0' mentre contested\_mem\_addr viene posto a '1'. Per abilitare la scrittura sui registri write è posto a '1'. Al termine del ciclo di clock la macchina passa allo stato DONE.
            \item DONE in questo stato vengono semplicemente abilitate le uscite o\_z1..o\_z3 ponendo il valore out\_en a '1'. Da notare che out\_en corrisponde all'uscita o\_done che quindi assume valore '1' durante questo stato. Dopo un solo ciclo di clock si ritorna allo stato WAIT\_START.
        \end{itemize}
        Di seguito quindi riportiamo un grafico rappresentante il comportamento della FSM. Le uscite non specificate hanno valori di default.\\
        \includegraphics[scale = 0.6, center]{images/FSM.png}
    \label{supporto}
    \subsection{Moduli di supporto}
        Per ridurre il tempo richiesto per le elaborazioni da compiere tra i\_start = '0' e o\_done = '1' e garantire il corretto funzionamento del componente abbiamo aggiunto anche dei processi di supporto.
        \subsubsection{Supporto 1 - o\_mem\_en}
            Il primo modulo di supporto è combinatorio compie l'assegnamento:
                o\_mem\_out <= contested\_mem\_en and not i\_start;
            Ciò, data la struttura della FSM implica che o\_mem\_en abbia il valore '1' solamente nel ciclo di clock appena successivo al termine dell'input, cosa che permette una richiesta immediata di lettura dalla memoria.
        \subsubsection{Supporto 2 - o\_done}
            Il secondo modulo di supporto è un componente che assegna il valore di out\_en ad o\_done ad ogni fronte di discesa del clock.
            Questo modulo inoltre gestisce out\_en in modo da mostrare o meno il contenuto dei registri reg\_z0..reg\_z3 sulle uscite corrispettive.
    \subsection{Schematica completa}
        Alla luce di quanto esposto in questa sezione riportiamo una schematica più precisa del componente richiesto.\\
        \includegraphics[scale = 0.45, center]{images/componente_new.png}

\pagebreak



\section{Risultati Sperimentali}
\subsection{Sintesi}
\subsubsection{Utilization}
    La sintesi ha prodotto un design semplificato molto intuitivo e semplice.
    Come è possibile verificare dal report utilization:
    
    \begin{center}
    \begin{small}
    \begin{verbatim}
1. Slice Logic
+-------------------------+------+-------+------------+-----------+-------+
|        Site Type        | Used | Fixed | Prohibited | Available | Util% |
+-------------------------+------+-------+------------+-----------+-------+
| Slice LUTs*             |   28 |     0 |          0 |    134600 |  0.02 |
|   LUT as Logic          |   28 |     0 |          0 |    134600 |  0.02 |
|   LUT as Memory         |    0 |     0 |          0 |     46200 |  0.00 |
| Slice Registers         |   53 |     0 |          0 |    269200 |  0.02 |
|   Register as Flip Flop |   53 |     0 |          0 |    269200 |  0.02 |
|   Register as Latch     |    0 |     0 |          0 |    269200 |  0.00 |
| F7 Muxes                |    0 |     0 |          0 |     67300 |  0.00 |
| F8 Muxes                |    0 |     0 |          0 |     33650 |  0.00 |
+-------------------------+------+-------+------------+-----------+-------+
    \end{verbatim}
    \end{small}
    \end{center}
    Vengono generati esclusivamente flip-flop, nello specifico il numero utilizzato è molto vicino al limite fisico per svolgere le funzioni richieste (50 flip-flop è la richiesta minima: 32 i registri in uscita e 18 registri di deserializzazione in ingresso).
    \subsubsection{Timing}
    Il report timing offre un'analisi del circuito sull'evoluzione temporale in relazione al clock:
    \begin{center}
    \begin{small}
    \begin{verbatim}
Timing Report
Slack (MET) :             47.473ns  (required time - arrival time)
  Source:                 FSM_sequential_curr_state_reg[2]/C
                            (rising edge-triggered cell FDCE clocked by clock)
  Destination:            reg_z1_reg[0]/CE
                            (falling edge-triggered cell FDCE clocked by clock)
  Path Group:             clock
  Path Type:              Setup (Max at Slow Process Corner)
  Requirement:            50.000ns  (clock fall@50.000ns - clock rise@0.000ns)
  Data Path Delay:        2.148ns  (logic 0.751ns (34.963%)  route 1.397ns (65.037%))
  Logic Levels:           1  (LUT5=1)
  Clock Path Skew:        -0.145ns (DCD - SCD + CPR)
    Destination Clock Delay (DCD):    2.100ns = ( 52.100 - 50.000 ) 
    Source Clock Delay      (SCD):    2.424ns
    Clock Pessimism Removal (CPR):    0.178ns
  Clock Uncertainty:      0.035ns  ((TSJ^2 + TIJ^2)^1/2 + DJ) / 2 + PE
    Total System Jitter     (TSJ):    0.071ns
    Total Input Jitter      (TIJ):    0.000ns
    Discrete Jitter          (DJ):    0.000ns
    Phase Error              (PE):    0.000ns
    \end{verbatim}
    \end{small}
    \end{center}
    Lo Slack calcolato è sostanziale, permette quindi fino una riduzione di un ordine di grandezza al periodo del clock seguendo i costraint stabiliti.
    La pista più lenta del circuito potrebbe quindi finire i calcoli dopo 2.527ns dall'inizio del sollecitamento.
    
    \subsection{Schematica}
    Vale la pena illustrare brevemente la schematica generata composta principalmente da 3 parti:
    \begin{itemize}
        \item FSM one-hot encoded, generata automaticamente con questo encoding rende la transizione ancora più veloce (4 stati rappresentati in one-hot il rapporto costo prestazioni è alto, il costo è di soli 2 flip-flop);
        \item blocco di de-serializzazione, la sola parte la cui generazione è stata affidata interamente ad una libreria. La sintesi risultante è minima con 18 flip-flop;
        \item blocco registri uscite e LUT di trasparenza, contenenti anche logica per gestire il segnale DONE.
    \end{itemize}
    \includegraphics[scale=1, center]{images/schematic.png}

\pagebreak
\section{Simulazioni}
    \subsection{Generale funzionamento e casi base}
    Sono state eseguite varie simulazioni di casi non limite e di funzionamento ordinario.
    \\
    Verranno riportate a seguito alcuni diagrammi generati in post sintesi signifativi per il tipo di controllo in base alla specifica da testare.
    \\
    Tra queste il testbench fornito dai docenti:
    \\
    \includegraphics[scale=0.35, center]{images/tb_example.png}
    \\
    E altre 4 simulazioni con lunghezza di input variabile troppo lunghe per essere mostrate leggibilmente.
\subsection{Reset}
    è fondamentale un'analisi da cima a fondo sugli effetti del reset, esaminando la risposta del componente ad un segnale di reset in qualsiasi istante possibile.
\subsubsection{Reset tra utilizzi}
    Un segnale di reset posto con il componente a riposo, non in elaborazione. 
    \\
    \includegraphics[scale=0.35, center]{images/tb_4.png}
\subsubsection{Reset in acquisizione}
    Per l'acquisizione dei 18 bit in ingresso accade durante 2 stati della FSM, la verifica delle funzionalità non è semplice.
    \\
    La differenza di stato è cruciale perché mentre il primo punta ad acquisire solo i 2 bit di indirizzo per l'uscita, il secondo stato di acquisizione esegue anche preparazioni per la richiesta alla memoria in attesa della fine del segnale.
    \\
    Viene quindi proposto un primo grafico di una simulazione dove il reset viene stimolato durante l'acquisizione dei primi 2 bit, incominciando una nuova operazione senza che il segnale START vada a '0'.
    \\
    \includegraphics[scale=0.35, center]{images/tb_reset_extra.png}
    La successiva simulazione mostra come un reset nella fase di acquisizione dei bit relativi all'indirizzo della memoria funziona correttamente.
    \\
    \includegraphics[scale=0.35, center]{images/tb_12.png}
\subsubsection{Reset in richiesta alla memoria}
    Il componente a seguito della fine di una sequenza in ingresso prepara una richiesta alla memoria, è stato quindi testato con successo che il segnale di enable\_wire cessi correttamente
    \\
    \includegraphics[scale=0.35, center]{images/tb_13.png}

\subsubsection{Reset in scrittura registri interni}
    Nel caso di reset quando la FSM del componente si trova nella fase di salvataggio dei dati dall'uscita della memoria ai registri interni, il componente reagisce correttamente azzerando comunque in modo asincrono i registri, lo stato della FSM e le uscite. Il grafico di una simulazione segue:
    \\
    \includegraphics[scale=0.35, center]{images/tb_14.png}

\subsubsection{Reset in fase finale}
    La fase che espone i valori alle uscite è la più "delicata", se il componente riceve un segnale \textbf{reset} mentre il segnale DONE è attivo, questo immediatamente tronca \textbf{DONE} a zero insieme ai segnali di uscita \textbf{Z}. Segue il diagramma una simulazione a riguardo:
    \\
    \includegraphics[scale=0.35, center]{images/tb_15.png}









\label{conclusioni}
\section{Conclusioni}
    
    Nel nostro progetto abbiamo posto il focus non solo sull'ottenere un componente funzionante sia in pre che in post sintesi ma anche sul migliorarne il più possibile le performance spingendoci oltre i requisiti richiesti.
    Grazie ad un analisi della schematica e delle simulazioni siamo stati in grado di ottenere un'implementazione del componente in grado di completare le operazioni richieste dalla specifica in 3 semicicli di clock.
    Seppure questa scelta possa essere più rischiosa in quanto ci ha obbligato a lavorare su entrambi i fronti del clock complicando non solo il codice ma anche la logica di comportamento del componente, riteniamo fosse la quella migliore. Infatti ci ha permesso di ragionare a fondo e trovare soluzioni ad un numero molto maggiore di problemi, cosa che ci ha permesso di approfondire maggiormente la materia. 
    Inoltre riteniamo di essere stati in grado di ottenere un risultato finale relativamente chiaro, efficiente, sicuro e che utilizza un basso numero di flip-flop.
    In ogni caso siamo perfettamente consapevoli che nel mondo lavorativo una volta rispettate le specifiche lo sforzo per incrementare le performance non sia necessario ed anzi possa portare a correre rischi evitabili. Tuttavia essendo un progetto universitario abbiamo ritenuto che lo sforzo di ottimizzazione (anche alla luce delle tematiche del corso) potesse essere apprezzato.


\end{document}
